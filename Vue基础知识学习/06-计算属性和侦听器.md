@[toc](计算属性和侦听器)

# 计算属性
## 计算属性的使用方法
&emsp;&emsp;模板内的表达式非常便利，但是设计它们的初衷是用于简单运算，在模板中放入太多的逻辑会让模板过重且难以维护。所以，对于任何复杂逻辑，你都应该使用计算属性。

+ computed选项定义计算属性
+ 计算属性类似于methods选项中定义的函数
  + 计算属性会进行缓存，只在相关响应依赖发生变化时它们才会重新求值
  + 函数每次都会执行函数体进行计算

  ```html
<!-- 01-计算属性.html -->
<body>
    <div id="app">
        <p>原始数据： {{ message }}</p>
        <p>计算属性转换后的数据：{{ reversedMessage }}</p>
    </div>
    <script src="./node_modules/vue/dist/vue.js"></script>
    <script>
       let vm = new Vue({
            data: {
                message : 'Hello'
            },
            computed: {
                // 计算属性的getter方法
                reversedMessage () {
                    return this.message.split('').reverse().join('')
                }
            },
        }).$mount('#app')
    </script>
</body>
  ```

&emsp;&emsp;当你打开浏览器的控制台，修改vm.message的值的时候，vm.reversedMessage的值也会立即发生改变。你可以像绑定普通函数一样在模板中绑定计算属性，Vue知道vm.reversedMessage依赖于vm.message，因此当vm.message发生变化时，所有依赖vm.reversedMessage的绑定也会更新。

## 计算属性 VS 方法
  
&emsp;&emsp;上面的案例通过方法也可以实现：
  
```html
<!-- 02-方法实现案例 -->
  <body>
    <div id="app">
        <p>原始数据： {{ message }}</p>
        <p>方法转换后的数据：{{ reversedMessage() }}</p>
    </div>
    <script src="./node_modules/vue/dist/vue.js"></script>
    <script>
        new Vue({
            data: {
                message: 'Hello'
            },
            methods: {
                reversedMessage () {
                    return this.message.split('').reverse().join('')
                } 
            },
        }).$mount('#app')
  </script>
  </body>
  ```

&emsp;&emsp;两种方式的最终结果是完全相同的，不同的是计算属性是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时候它们才会重新求值。这就意味着只要message还没有发生变化，多次访问计算属性会立即返回之前的计算结果，而不是再次执行函数。

&emsp;&emsp;相比之下，每当触发重新渲染时，调用方法总会再次执行函数。

## 计算属性的setter
&emsp;&emsp;函数只支持单向，计算属性默认只有getter，不过在需要时你也可以提供一个setter：

```html
<!-- 03-计算属性的setter方法.html -->
<body>
    <div id="app">
        <p>firstname: {{ firstname }}</p>
        <p>lastname: {{ lastname }}</p>
        <p>fullname: {{ fullname }}</p>
    </div>
    <script src="./node_modules/vue/dist/vue.js"></script>
    <script>
        let vm = new Vue({
            data: {
                firstname: 'John',
                lastname: 'Smith'
            },
            computed: {
                fullname : {
                    get : function () {
                        return this.firstname + ' ' + this.lastname
                    },
                    set : function (newValue) {
                        let arrays = newValue.split(' ')
                        this.firstname = arrays[0]
                        this.lastname = arrays[arrays.length - 1]
                    }
                }
            },
        }).$mount('#app')
        vm.fullname = 'Jack Wade'   // 调用setter方法，修改firstname和lastname的值
    </script>
</body>
```

&emsp;&emsp;当改变fullname的值的时候，就会执行setter方法。

# 侦听器
&emsp;&emsp;虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。Vue提供了一种更通用的方式来观察和响应Vue实例上的数据变动：侦听属性。当需要在数据变化时执行异步或开销较大的操作时，这个方法是最有用的。

```html
<!-- 04-侦听器-选项方法.html -->
<body>
    <div id="app">

    </div>
    <script src="./node_modules/vue/dist/vue.js"></script>
    <script>
        let vm = new Vue({
            data: {
                message: 'Hello Vue'
            },
            watch: {
                message:  function (newValue, oldValue) {
                    console.log(newValue, oldValue)
                }
            },
        }).$mount('#app')

        vm.message = 'Hell World'
        //  打印 Hello World Hello Vue
    </script>
</body>
```

&emsp;&emsp;除了watch选项外，还可以使用命令式的vm.$watch()来实现。

```html
<!-- 05-实例方法使用watch.html -->
<body>
    <div id="app"></div>
    <script src="./node_modules/vue/dist/vue.js"></script>
    <script>
        let vm = new Vue({
            data: {
                message: 'Hello Vue'
            }
        }).$mount('#app')

        vm.$watch('message', function(newValue, oldValue) { 
            console.log(newValue, oldValue)
        })

        // Hello World Hello Vue
        vm.message = 'Hello World'
    </script>
</body>
```

## 计算属性 VS 侦听器
&emsp;&emsp;当你有一些数据需要随着其它数据变动而变动时，很容易滥用watch，下面是通过侦听器的方法实现上面的计算属性的案例：

```html
<!--  -->
<body>
    <div id="app">
        <p>原始数据： {{ message }}</p>
        <p>侦听器转换后的数据：{{ reversedMessage }}</p>
    </div>
    <script src="./node_modules/vue/dist/vue.js"></script>
    <script>
        new Vue({
            data: {
                message: 'Hello',
                reversedMessage: 'olleH'
            },
            watch: {
                message: function (newValue, oldValue) {
                    this.reversedMessage = newValue.split('').reverse().join('')
                }
            },
        }).$mount('#app')
    </script>
</body>
```